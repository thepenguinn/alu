\documentclass[../main]{subfiles}

\ifSubfilesClassLoaded{
    \input{tikzset}
    \input{subctikz}
    %% um, why did I add this...
    %% \input{../onebitalu/tikzset}
    %% \input{../onebitalu/subctikz}
    %% \tikzexternalize[prefix=figcache/]
    \usepackage{catppuccintheme}
    %% \usemintedstyle{catppuccin-mocha}
    %% \ctikzset{open poles fill = black}
} {
}

\begin{document}

%%%% Some definitions

\def\truthTableWidth{0.4\textwidth}
\renewcommand\tabularxcolumn[1]{m{#1}}%
\newcolumntype{G}{>{\centering\arraybackslash}X}
\newcolumntype{T}{>{\centering\arraybackslash}m{\truthTableWidth}}

%%%%

\chapter{Basic Circuits}

\section {FlipFlops} \label{sec:flipflops}

\subsection {SR Latch} \label{sec:srlatch}

\begin{figure} [!ht]

    \renewcommand\tabularxcolumn[1]{m{#1}}%
    %% \newcolumntype{G}{>{\centering\arraybackslash}X}
    %% \newcolumntype{T}{>{\centering\arraybackslash}m{0.3\textwidth}}

    \begin{tabularx} {\textwidth} {*{1}G*{1}G}
        \centering
        \vfill
        \resizebox {0.3\textwidth} {!} {
            \begin{tikzpicture} [american]
                \draw
                (0,0)
                \gLvlSRLatch {srl} {s}
                (srl-s)    node [ocirc] {}
                (srl-r)    node [ocirc] {}
                (srl-q)    node [ocirc] {}
                (srl-qbar) node [ocirc] {}
                (srl-s)    node [left = 4pt]             {\texttt{S}}
                (srl-r)    node [left = 4pt]             {\texttt{R}}
                (srl-q)    node [right = 4pt]            {\texttt{Q}}
                (srl-qbar) node [right = 4pt]        {\texttt{\={Q}}}
                ;
            \end{tikzpicture}
        }
        \vfill
        &
        %% \begin{tabularx} {>{\centering}m{0.5\linewidth}m{0.5\linewidth}}
        \vfill
        {\begin{tabularx} {\truthTableWidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{S}} & \textsc{\textbf{R}} & \textsc{\textbf{Q\textsubscript{$t+1$}}} \\
            \midrule
            0   &  0  &   Q\textsubscript{t} \\
            0   &  1  &       0 \\
            1   &  0  &       1 \\
            1   &  1  &    $Invalid$\\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure}{SR Latch}
        \label{fig:glvlsrlatch}
        &
        \captionof{table}{Truth Table of SR Latch}
        \label{tbl:ttsrlatch} \\
        \end{tabularx}

\end{figure}

Table: \ref{tbl:ttsrlatch} and Figure: \ref{fig:glvlsrlatch}

\subsubsection{Verilog Implementation} \label{hdl:srlatch}

\begin{minted}[mathescape] {verilog}
    module sr_latch(input logic set, reset,
        output logic q, qbar);

        nor #3 (q, qbar, reset);
        nor #3 (qbar, q, set);

    endmodule
\end{minted}

\subsection {SR FlipFlop} \label{sec:srflipflop}

\begin{figure} [!h]
    \begin{tabularx} {\textwidth} {*{1}G*{1}T}
        \centering
        \vfill
        \resizebox{0.5\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlSRFlipFlop {srff} {s}

                (srff-s)    node [ocirc] {}
                (srff-r)    node [ocirc] {}
                (srff-q)    node [ocirc] {}
                (srff-qbar) node [ocirc] {}
                (srff-clk) node [ocirc] {}

                (srff-s)    node [left = 4pt]             {\texttt{S}}
                (srff-r)    node [left = 4pt]             {\texttt{R}}
                (srff-q)    node [right = 4pt]            {\texttt{Q}}
                (srff-qbar) node [right = 4pt]        {\texttt{\={Q}}}
                (srff-clk)  node [left = 4pt]           {\texttt{CLK}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {\truthTableWidth} {*{4}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{CLK}} & \textsc{\textbf{S}} & \textsc{\textbf{R}} & \textsc{\textbf{Q\textsubscript{$t+1$}}} \\
            \midrule
            0   &   0   &  0  &    $Invalid$ \\
            0   &   0   &  1  &       0 \\
            0   &   1   &  0  &       1 \\
            0   &   1   &  1  &    Q\textsubscript{t} \\
            1   &   X   &  X  &    Q\textsubscript{t} \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \caption{SR FlipFlop}
        \label{fig:glvlsrflipflop}
        &
        \captionof{table}{Truth Table of SR FlipFlop}
        \label{tbl:ttsrflipflop} \\
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:srflipflop}

\begin{minted}[mathescape] {verilog}
    module sr_flipflop(input logic set, reset, clk,
        output logic q, qbar);

        /*
         * With active low clk
         * */

        wire srlset, srlreset;

        /* Refer, (section $\ref{hdl:srlatch}$) */
        sr_latch srl (
            .set(srlset),
            .reset(srlreset),
            .q(q),
            .qbar(qbar)
        );

        nor #3 (srlreset, set, clk);
        nor #3 (srlset, reset, clk);

    endmodule
\end{minted}

\subsection {D FlipFlop} \label{sec:dflipflop}

\begin{figure} [!hb]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlDFlipFlop {dff} {s}

                (dff-d)    node [ocirc] {}
                (dff-q)    node [ocirc] {}
                (dff-qbar) node [ocirc] {}
                (dff-clk) node [ocirc]  {}

                (dff-d)    node [left = 4pt]             {\texttt{D}}
                (dff-clk)  node [left = 4pt]           {\texttt{CLK}}
                (dff-q)    node [right = 4pt]            {\texttt{Q}}
                (dff-qbar) node [right = 4pt]        {\texttt{\={Q}}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{CLK}} & \textsc{\textbf{D}} & \textsc{\textbf{Q\textsubscript{t+1}}} \\
            \midrule
            0   &   0   &   0   \\
            0   &   1   &   1   \\
            1   &   X   &   Q\textsubscript{t}   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure}{D FlipFlop}
        \label{fig:glvldflipflop}
        &
        \captionof{table}{Truth Table of D FlipFlop}
        \label{tbl:dflipflop}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:dflipflop}

\begin{minted}[mathescape] {verilog}
    module d_flipflop(input logic data, clk,
        output logic q, qbar);

        /*
         * With active low clk
         * */

         wire notdata;

        /* Refer, (section $\ref{hdl:srflipflop}$) */
        sr_flipflop srff (
            .set(data),
            .reset(notdata),
            .clk(clk),
            .q(q),
            .qbar(qbar)
        );

        nor #3 (notdata, data, data);

    endmodule
\end{minted}

\subsection {D FlipFlop with Synchronous Reset} \label{sec:dflipflopsr}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlDFlipFlopSR {dffsr} {s}

                (dffsr-d)    node [ocirc] {}
                (dffsr-q)    node [ocirc] {}
                (dffsr-qbar) node [ocirc] {}
                (dffsr-clk)  node [ocirc] {}
                (dffsr-rst)  node [ocirc] {}

                (dffsr-d)    node [left = 4pt]             {\texttt{D}}
                (dffsr-clk)  node [left = 4pt]           {\texttt{CLK}}
                (dffsr-q)    node [right = 4pt]            {\texttt{Q}}
                (dffsr-qbar) node [right = 4pt]        {\texttt{\={Q}}}
                (dffsr-rst)  node [below = 4pt]          {\texttt{RST}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{4}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{CLK}} & \textsc{\textbf{RST}} & \textsc{\textbf{D}} & \textsc{\textbf{Q\textsubscript{t+1}}} \\
            \midrule
            0   &   0   &   0   &   1   \\
            0   &   0   &   1   &   0   \\
            0   &   1   &   X   &   0   \\
            1   &   X   &   X   &   Q\textsubscript{t}   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \caption{D FlipFlop with Synchronous Reset}
        \label{fig:glvldflipflopsr}
        &
        \captionof{table}{Truth Table of D FlipFlop with Synchronous Reset}
        \label{tbl:dflipflopsr}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:dflipflopsr}

\begin{minted}[mathescape] {verilog}
    module d_flipflop_sr(input logic data, rst, clk,
        output logic q, qbar);

        /*
         * With active low clk and active low data
         * */

        wire acdata;

        /* Refer, (section $\ref{hdl:dflipflop}$) */
        d_flipflop dl (
            .data(acdata),
            .clk(clk),
            .q(q),
            .qbar(qbar)
        );

        nor #3 (acdata, data, rst);

    endmodule
\end{minted}

\subsection {MS FlipFlop} \label{sec:msflipflop}

\begin{figure} [!hb]
    \centering
    \resizebox{\textwidth}{!} {
        \begin{tikzpicture} [american]

            \draw
            (0,0)

            \gLvlMSFlipFlop {msff} {s}

            (msff-d)     node [ocirc] {}
            (msff-rst)   node [ocirc] {}
            (msff-q)     node [ocirc] {}
            (msff-qbar)  node [ocirc] {}
            (msff-reclk) node [ocirc] {}
            (msff-feclk) node [ocirc] {}

            (msff-d)     node [left = 4pt]             {\texttt{D}}
            (msff-rst)   node [below = 4pt]          {\texttt{RST}}
            (msff-q)     node [right = 4pt]            {\texttt{Q}}
            (msff-qbar)  node [right = 4pt]        {\texttt{\={Q}}}
            (msff-reclk) node [above = 4pt]        {\texttt{RECLK}}
            (msff-feclk) node [above = 4pt]        {\texttt{FECLK}}

            ;

            %% Drawing a table to indicate the active state of
            %% inputs

            \draw
            (msff-northeast)

            node (mgla1) [align = center, anchor = north east] {

                \begin{tabularx} {0.33\textwidth} {*{2}{>{\raggedleft\arraybackslash}X}}
                                    &       \texttt{INPUTS} \\
                    \midrule
                    \texttt{D}      &   \texttt{ACTIVE LOW} \\
                    \texttt{RST}    &  \texttt{ACTIVE HIGH} \\
                    \texttt{RECLK}  &   \texttt{ACTIVE LOW} \\
                    \texttt{FECLK}  &   \texttt{ACTIVE LOW} \\
                \end{tabularx}

            }

            (msff-southwest)

            node (mgla2) [align = center, anchor = south west] {

                \begin{tabularx} {0.33\textwidth} {*{1}{>{\raggedright\arraybackslash}p{0.4cm}}*{1}{>{\raggedright\arraybackslash}X}}
                    \multicolumn{2}{l}{\texttt{OUTPUTS}}     \\
                    \midrule
                    \texttt{Q}       & \texttt{ACTIVE HIGH}  \\
                    \texttt{\={Q}}   & \texttt{ACTIVE LOW}  \\
                \end{tabularx}

            }

            ;


        \end{tikzpicture}
    }
    \caption{MS FlipFlop}
    \label{fig:glvlmsflipflop}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:msflipflop}

\begin{minted}[mathescape] {verilog}
    module ms_flipflop(input logic data, rst, reclk, feclk,
        output logic q, qbar);

        /*
         * With synchronous reset, active low data,
         * active low reclk, and feclk
         * */

        wire sdata, notsdata;

        /* Refer, (section $\ref{hdl:dflipflopsr}$) */
        d_flipflop_sr master (
            .data(data),
            .clk(reclk),
            .q(sdata),
            .qbar(notsdata),
            .rst(rst)
        );

        /* Refer, (section $\ref{hdl:srflipflop}$) */
        sr_flipflop slave (
            .set(sdata),
            .reset(notsdata),
            .clk(feclk),
            .q(q),
            .qbar(qbar)
        );

    endmodule
\end{minted}

\section{Multiplexer}

\subsection {Five Input NOR Gate from Two Input NOR Gate}

\begin{minted} {verilog}
    module nor5input(input logic in0, in1, in2, in3, in4,
        output logic out, f4high);

        wire nor01, nor23;
        wire or01, or23;
        wire nor0123;
        wire or0123;

        nor #3 (nor01, in0, in1);
        nor #3 (or01, nor01, nor01);

        nor #3 (nor23, in2, in3);
        nor #3 (or23, nor23, nor23);

        nor #3 (nor0123, or01, or23);
        nor #3 (or0123, nor0123, nor0123);

        nor #3 (out, or0123, in4);

        assign f4high = or0123;

    endmodule
\end{minted}

\subsection {Four Input NOR Gate from Two Input NOR Gate}

\begin{minted} [mathescape] {verilog}
    module nor4input(input logic in0, in1, in2, in3,
        output logic out);

        wire nor01, nor23;
        wire or01, or23;

        nor #3 (nor01, in0, in1);
        nor #3 (or01, nor01, nor01);

        nor #3 (nor23, in2, in3);
        nor #3 (or23, nor23, nor23);

        nor #3 (out, or01, or23);

    endmodule
\end{minted}


\subsection {A 16 to 1 Multiplexer}

\begin{minted} {verilog}
    module mux16(input logic [15:0] in, input logic [3:0] sl,
        output logic out, muxlast);

        wire sl00, sl01, sl02, sl03; // original select lines
        wire sl10, sl11, sl12, sl13; // inverted select lines

        assign sl00 = sl[0];
        assign sl01 = sl[1];
        assign sl02 = sl[2];
        assign sl03 = sl[3];

        nor #3 (sl10, sl00, sl00);
        nor #3 (sl11, sl01, sl01);
        nor #3 (sl12, sl02, sl02);
        nor #3 (sl13, sl03, sl03);

        wire nor00, nor01, nor02, nor03, nor04, nor05, nor06, nor07,
            nor08, nor09, nor10, nor11, nor12, nor13, nor14, nor15;

        nor5input nor500 (.in0(sl03), .in1(sl02), .in2(sl01), .in3(sl00), .in4(in[00]),
        .out(nor00));
        nor5input nor501 (.in0(sl03), .in1(sl02), .in2(sl01), .in3(sl10), .in4(in[01]),
        .out(nor01));
        nor5input nor502 (.in0(sl03), .in1(sl02), .in2(sl11), .in3(sl00), .in4(in[02]),
        .out(nor02));
        nor5input nor503 (.in0(sl03), .in1(sl02), .in2(sl11), .in3(sl10), .in4(in[03]),
        .out(nor03));
        nor5input nor504 (.in0(sl03), .in1(sl12), .in2(sl01), .in3(sl00), .in4(in[04]),
        .out(nor04));
        nor5input nor505 (.in0(sl03), .in1(sl12), .in2(sl01), .in3(sl10), .in4(in[05]),
        .out(nor05));
        nor5input nor506 (.in0(sl03), .in1(sl12), .in2(sl11), .in3(sl00), .in4(in[06]),
        .out(nor06));
        nor5input nor507 (.in0(sl03), .in1(sl12), .in2(sl11), .in3(sl10), .in4(in[07]),
        .out(nor07));
        nor5input nor508 (.in0(sl13), .in1(sl02), .in2(sl01), .in3(sl00), .in4(in[08]),
        .out(nor08));
        nor5input nor509 (.in0(sl13), .in1(sl02), .in2(sl01), .in3(sl10), .in4(in[09]),
        .out(nor09));
        nor5input nor510 (.in0(sl13), .in1(sl02), .in2(sl11), .in3(sl00), .in4(in[10]),
        .out(nor10));
        nor5input nor511 (.in0(sl13), .in1(sl02), .in2(sl11), .in3(sl10), .in4(in[11]),
        .out(nor11));
        nor5input nor512 (.in0(sl13), .in1(sl12), .in2(sl01), .in3(sl00), .in4(in[12]),
        .out(nor12));
        nor5input nor513 (.in0(sl13), .in1(sl12), .in2(sl01), .in3(sl10), .in4(in[13]),
        .out(nor13));
        nor5input nor514 (.in0(sl13), .in1(sl12), .in2(sl11), .in3(sl00), .in4(in[14]),
        .out(nor14));
        nor5input nor515 (.in0(sl13), .in1(sl12), .in2(sl11), .in3(sl10), .in4(in[15]),
        .out(nor15), .f4high(muxlast));

        wire fnor0, fnor1, fnor2, fnor3;
        wire for0, for1, for2, for3;

        nor #3 (for0, fnor0, fnor0);
        nor #3 (for1, fnor1, fnor1);
        nor #3 (for2, fnor2, fnor2);
        nor #3 (for3, fnor3, fnor3);

        nor4input nor400 (.in0(nor00), .in1(nor01), .in2(nor02), .in3(nor03), .out(fnor0));
        nor4input nor401 (.in0(nor04), .in1(nor05), .in2(nor06), .in3(nor07), .out(fnor1));
        nor4input nor402 (.in0(nor08), .in1(nor09), .in2(nor10), .in3(nor11), .out(fnor2));
        nor4input nor403 (.in0(nor12), .in1(nor13), .in2(nor14), .in3(nor15), .out(fnor3));

        nor4input nor404 (.in0(for0), .in1(for1), .in2(for2), .in3(for3), .out(out));

    endmodule
\end{minted}

\subsection {An Abstracted Schematic of A 16 to 1 Multiplexer}

\begin{figure} [!h]
    \centering
    \resizebox{\textwidth}{!} {
        \begin{tikzpicture}

            \draw [thick, color = catppuccinfg]
            % \draw [thick, color = {rgb:red,100;green,50;blue,20}]
            % \draw [thick, color = \color{draculafg}]
            (0,0)
            \muxSixteen {mux} {out}

            \labelmuxSixteenFl {mux}
            {\texttt{FL 07}}
            {\texttt{FL 06}}
            {\texttt{FL 05}}
            {\texttt{FL 04}}
            {\texttt{FL 03}}
            {\texttt{FL 02}}
            {\texttt{FL 01}}
            {\texttt{FL 00}}

            \labelmuxSixteenSl {mux}
            {\texttt{SECOND LAYER}}

            (mux-in00) node [ocirc] {}
            (mux-in01) node [ocirc] {}
            (mux-in02) node [ocirc] {}
            (mux-in03) node [ocirc] {}
            (mux-in04) node [ocirc] {}
            (mux-in05) node [ocirc] {}
            (mux-in06) node [ocirc] {}
            (mux-in07) node [ocirc] {}
            (mux-in08) node [ocirc] {}
            (mux-in09) node [ocirc] {}
            (mux-in10) node [ocirc] {}
            (mux-in11) node [ocirc] {}
            (mux-in12) node [ocirc] {}
            (mux-in13) node [ocirc] {}
            (mux-in14) node [ocirc] {}
            (mux-in15) node [ocirc] {}

            (mux-in00) node [above = 4pt] {\texttt{I\textsubscript{00}}}
            (mux-in01) node [above = 4pt] {\texttt{I\textsubscript{01}}}
            (mux-in02) node [above = 4pt] {\texttt{I\textsubscript{02}}}
            (mux-in03) node [above = 4pt] {\texttt{I\textsubscript{03}}}
            (mux-in04) node [above = 4pt] {\texttt{I\textsubscript{04}}}
            (mux-in05) node [above = 4pt] {\texttt{I\textsubscript{05}}}
            (mux-in06) node [above = 4pt] {\texttt{I\textsubscript{06}}}
            (mux-in07) node [above = 4pt] {\texttt{I\textsubscript{07}}}
            (mux-in08) node [above = 4pt] {\texttt{I\textsubscript{08}}}
            (mux-in09) node [above = 4pt] {\texttt{I\textsubscript{09}}}
            (mux-in10) node [above = 4pt] {\texttt{I\textsubscript{10}}}
            (mux-in11) node [above = 4pt] {\texttt{I\textsubscript{11}}}
            (mux-in12) node [above = 4pt] {\texttt{I\textsubscript{12}}}
            (mux-in13) node [above = 4pt] {\texttt{I\textsubscript{13}}}
            (mux-in14) node [above = 4pt] {\texttt{I\textsubscript{14}}}
            (mux-in15) node [above = 4pt] {\texttt{I\textsubscript{15}}}

            (mux-sl0) node [ocirc] {}
            (mux-sl1) node [ocirc] {}
            (mux-sl2) node [ocirc] {}
            (mux-sl3) node [ocirc] {}

            (mux-sl0) node [left = 4pt] {\texttt{SL\textsubscript{0}}}
            (mux-sl1) node [left = 4pt] {\texttt{SL\textsubscript{1}}}
            (mux-sl2) node [left = 4pt] {\texttt{SL\textsubscript{2}}}
            (mux-sl3) node [left = 4pt] {\texttt{SL\textsubscript{3}}}

            (mux-out) node [ocirc] {}
            (mux-out) node [below = 4pt] {\texttt{OUT}}

            (mux-muxlast) node [circleinv, fill = circleinvfillcolor, anchor = top] {}

            (mux-muxlast)
            -- (mux-muxlast|-mux-out)

            coordinate (muxlast)
            (muxlast) node [ocirc] {}
            (muxlast) node [below = 4pt] {\texttt{MUXLAST}}

            ;

        \end{tikzpicture}
    }
    \caption{Schematic of a 16 to 1 MUX}
\end{figure}

\section {Edge Dectectors}

\subsection {Falling Edge Dectector}

\begin{minted} {verilog}
    module edge_detector(input logic clk,
        output logic feclk);

        /*
         * Falling edge detector
         * */

        wire notclk;

        nor #30 (notclk, clk, clk);
        nor #3 (feclk, notclk, clk);

    endmodule
\end{minted}

\subsection {Falling Edge Dectector with Inverted Output}

\begin{minted} {verilog}
    module edge_detector_inv(input logic clk,
        output logic notfeclk);

        /*
         * Falling edge detector,
         * with inverted output
         * */

        wire notclk;
        wire feclk;

        nor #30 (notclk, clk, clk);
        nor #3 (feclk, notclk, clk);
        nor #3 (notfeclk, feclk, feclk);

    endmodule
\end{minted}

\section {Logic Gates} \label{sec:logicgates}

\subsection {XOR Gate} \label{sec:xorgate}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlXorGate {xor} {ain}

                (xor-ain)     node [ocirc] {}
                (xor-bin)     node [ocirc] {}
                (xor-yout)    node [ocirc] {}

                (xor-ain)    node [left = 4pt]    {\texttt{A}}
                (xor-bin)    node [left = 4pt]    {\texttt{B}}
                (xor-yout)  node [right = 4pt]    {\texttt{Y}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{A}} & \textsc{\textbf{B}} & \textsc{\textbf{Y}} \\
            \midrule
            0   &   0   &   0   \\
            0   &   1   &   1   \\
            1   &   0   &   1   \\
            1   &   1   &   0   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure} {XOR Gate Using NOR Gates}
        \label{fig:glvlxorgate}
        &
        \captionof{table} {Truth Table of XOR Gate}
        \label{tbl:ttxorgate}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:xorgate}

\begin{minted}[mathescape] {verilog}
    module xor_gate(input logic a, b,
        output logic y);

        wire anorb, nor1, nor2, xnor1;

        nor #3 (anorb, a, b);
        nor #3 (nor1, anorb, a);
        nor #3 (nor2, anorb, b);
        nor #3 (xnor1, nor1, nor2);
        nor #3 (y, xnor1, xnor1);

    endmodule
\end{minted}

\subsection {AND Gate} \label{sec:andgate}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlAndGate {and} {ain}

                (and-ain)     node [ocirc] {}
                (and-bin)     node [ocirc] {}
                (and-yout)    node [ocirc] {}

                (and-ain)    node [left = 4pt]    {\texttt{A}}
                (and-bin)    node [left = 4pt]    {\texttt{B}}
                (and-yout)  node [right = 4pt]    {\texttt{Y}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{A}} & \textsc{\textbf{B}} & \textsc{\textbf{Y}} \\
            \midrule
            0   &   0   &   0   \\
            0   &   1   &   0   \\
            1   &   0   &   0   \\
            1   &   1   &   1   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure} {AND Gate Using NOR Gates}
        \label{fig:glvlandgate}
        &
        \captionof{table} {Truth Table of AND Gate}
        \label{tbl:ttandgate}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:andgate}

\begin{minted}[mathescape] {verilog}
    module and_gate(input logic a, b,
        output logic y);

        wire anot, bnot;

        nor #3 (anot, a, a);
        nor #3 (bnot, b, b);
        nor #3 (y, anot, bnot);

    endmodule
\end{minted}

\subsection {OR Gate} \label{sec:orgate}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlOrGate {or} {ain}

                (or-ain)     node [ocirc] {}
                (or-bin)     node [ocirc] {}
                (or-yout)    node [ocirc] {}

                (or-ain)    node [left = 4pt]    {\texttt{A}}
                (or-bin)    node [left = 4pt]    {\texttt{B}}
                (or-yout)  node [right = 4pt]    {\texttt{Y}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{A}} & \textsc{\textbf{B}} & \textsc{\textbf{Y}} \\
            \midrule
            0   &   0   &   0   \\
            0   &   1   &   1   \\
            1   &   0   &   1   \\
            1   &   1   &   1   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure} {OR Gate Using NOR Gates}
        \label{fig:glvlorgate}
        &
        \captionof{table} {Truth Table of OR Gate}
        \label{tbl:ttorgate}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:orgate}

\begin{minted}[mathescape] {verilog}
    module or_gate(input logic a, b,
        output logic y);

        wire anorb;

        nor #3 (anorb, a, b);
        nor #3 (y, anorb, anorb);

    endmodule
\end{minted}

\subsection {NOT Gate} \label{sec:notgate}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlNotGate {not} {ain}

                (not-ain)     node [ocirc] {}
                (not-yout)    node [ocirc] {}

                (not-ain)    node [left = 4pt]    {\texttt{A}}
                (not-yout)  node [right = 4pt]    {\texttt{Y}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{2}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{A}} & \textsc{\textbf{Y}} \\
            \midrule
            0   &   1   \\
            1   &   0   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure} {NOT Gate Using NOR Gate}
        \label{fig:glvlnotgate}
        &
        \captionof{table} {Truth Table of NOT Gate}
        \label{tbl:ttnotgate}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:notgate}

\begin{minted}[mathescape] {verilog}
    module not_gate(input logic a,
        output logic y);

        nor #3 (y, a, a);

    endmodule
\end{minted}

\subsection {NOR Gate} \label{sec:norgate}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlNorGate {nor} {ain}

                (nor-ain)     node [ocirc] {}
                (nor-bin)     node [ocirc] {}
                (nor-yout)    node [ocirc] {}

                (nor-ain)    node [left = 4pt]    {\texttt{A}}
                (nor-bin)    node [left = 4pt]    {\texttt{B}}
                (nor-yout)  node [right = 4pt]    {\texttt{Y}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{A}} & \textsc{\textbf{B}} & \textsc{\textbf{Y}} \\
            \midrule
            0   &   0   &   1   \\
            0   &   1   &   0   \\
            1   &   0   &   0   \\
            1   &   1   &   0   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure} {NOR Gate Using NOR Gate}
        \label{fig:glvlnorgate}
        &
        \captionof{table} {Truth Table of NOR Gate}
        \label{tbl:ttnorgate}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:norgate}

\begin{minted}[mathescape] {verilog}
    module nor_gate(input logic a, b,
        output logic y);

        nor #3 (y, a, b);

    endmodule
\end{minted}

\subsection {NAND Gate} \label{sec:nandgate}

\begin{figure} [!ht]
    \def\truthTableWidth{0.35\textwidth}
    \begin{tabularx} {\textwidth} {GT}
        \centering
        \vfill
        \resizebox{0.6\textwidth}{!} {
            \begin{tikzpicture} [american]

                \draw
                (0,0)

                \gLvlNandGate {nand} {ain}

                (nand-ain)     node [ocirc] {}
                (nand-bin)     node [ocirc] {}
                (nand-yout)    node [ocirc] {}

                (nand-ain)    node [left = 4pt]    {\texttt{A}}
                (nand-bin)    node [left = 4pt]    {\texttt{B}}
                (nand-yout)  node [right = 4pt]    {\texttt{Y}}

                ;
            \end{tikzpicture}
        }
        \vfill
        &
        \vfill
        {\begin{tabularx} {0.75\linewidth} {*{3}{>{\centering\arraybackslash}X}}
            \toprule
            \textsc{\textbf{A}} & \textsc{\textbf{B}} & \textsc{\textbf{Y}} \\
            \midrule
            0   &   0   &   1   \\
            0   &   1   &   1   \\
            1   &   0   &   1   \\
            1   &   1   &   0   \\
            \bottomrule
        \end{tabularx}}
        \vfill
        \\
        \captionof{figure} {NAND Gate Using NOR Gates}
        \label{fig:glvlnandgate}
        &
        \captionof{table} {Truth Table of NAND Gate}
        \label{tbl:ttnandgate}
    \end{tabularx}
\end{figure}

\subsubsection{Verilog Implementation} \label{hdl:nandgate}

\begin{minted}[mathescape] {verilog}
    module nand_gate(input logic a, b,
        output logic y);

        wire nota, notb;
        wire andab;

        nor #3 (nota, a, a);
        nor #3 (notb, b, b);
        nor #3 (andab, nota, notb);
        nor #3 (y, andab, andab);

    endmodule

\end{minted}

\section {Full Adder}

\begin{minted}[mathescape] {verilog}
    module full_adder(input logic a, b, cin,
        output logic sum, cout);

        wire anorb;
        wire xnor1, xnor2;
        wire xnor1nor1, xnor1nor2, xnor2nor1, xnor2nor2;
        wire xnor1norcin;

        // sum
        nor #3 (anorb, a, b);
        nor #3 (xnor1nor1, a, anorb);
        nor #3 (xnor1nor2, b, anorb);
        nor #3 (xnor1, xnor1nor1, xnor1nor2);

        nor #3 (xnor1norcin, xnor1, cin);
        nor #3 (xnor2nor1, xnor1, xnor1norcin);
        nor #3 (xnor2nor2, cin, xnor1norcin);
        nor #3 (sum, xnor2nor1, xnor2nor2);

        // cout
        nor #3 (cout, xnor1norcin, anorb);

    endmodule
\end{minted}

%%% \section{Flipflops}
%%%
%%% \newcommand\testing[1] {
%%%
%%% }
%%%
%%% \tikzset{external/force remake=true}
%%%
%%% \subsection {SR Latch}
%%%
%%% \begin{figure} [!ht]
%%%     \centering
%%%     \resizebox{\textwidth}{!} {
%%%         \begin{tikzpicture}
%%%             \draw
%%%             \testing {billie}
%%%             ;
%%%         \end{tikzpicture}
%%%     }
%%%     \caption{SR Latch}
%%% \end{figure}
%%%
%%% \tikzset{external/force remake=false}
%%%
\end{document}
